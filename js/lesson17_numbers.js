'use strict';
let billion = 1000000000;
console.log(billion);
//
let billion = 1e9;  
console.log(billion);
console.log( 7.3e9 );  
let ms = 0.000001;
let ms = 1e-6; 
// 16-tx : 0x, после которого указывается число.
console.log( 0xff ); // 255
console.log( 0xFF ); // 255 (то же самое, регистр не имеет значения)
/* Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
 */
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
console.log( a == b ); // true, с двух сторон число 255
/* сть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt (рассмотрим позже в этой главе).
 */
/* toString(base)
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.

Например:
 */
let num = 255;
console.log( num.toString(16) );  // ff
console.log( num.toString(2) );   // 11111111
/* base может варьироваться от 2 до 36 (по умолчанию 10).

Часто используемые:

base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:
 */
console.log( 123456..toString(36) ); // 2n9c
/* Две точки для вызова метода
Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.

Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что после первой точки начинается десятичная часть. А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.

Также можно записать как (123456).toString(36).

Округление
Одна из часто используемых операций при работе с числами – это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:
 */
// Math.floor
/* Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2. */
// Math.ceil
/* Округление в большую сторону: 3.1 становится 4, а -1.1 — -1. */
// Math.round
/* Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1. */
/* Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
Н */
let num = 1.23456;
console.log( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
/* Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
 */
let num = 12.34;
console.log( num.toFixed(1) ); // "12.3"
/* Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:
 */
let num = 12.36;
console.log( num.toFixed(1) ); // "12.4"
О/* братите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:
 */
let num = 12.34;
console.log( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой

console.log( 1e500 ); // Infinity
console.log( 0.1 + 0.2 ); // 0.30000000000000004
О
console.log( 0.1.toFixed(20) ); // 0.10000000000000000555
/* надёжный способ — это округлить результат используя метод toFixed(n):
 */
let sum = 0.1 + 0.2;
console.log( sum.toFixed(2) ); // 0.30
// Помните, что метод toFixed всегда возвращает строку. 
let sum = 0.1 + 0.2;
console.log( +sum.toFixed(2) ); // 0.3
/* Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появляется при финальном делении */
console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
// Привет! Я – число, растущее само по себе!
console.log( 9999999999999999 ); // покажет 10000000000000000
/* Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
NaN представляет ошибку.
Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
 */
console.log( isNaN(NaN) ); // true
console.log( isNaN("str") ); // true
console.log( NaN === NaN ); // false
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

console.log( isFinite("15") ); // true
console.log( isFinite("str") ); // false, потому что специальное значение: NaN
console.log( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
/* Иногда isFinite используется для проверки, содержится ли в строке число:
 */
let num = +prompt("Enter a number", '');

// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
console.log( isFinite(num) );
/* Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.
 */
/* Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is (Определение SameValue).
 */
/* parseInt и parseFloat
Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
 */
console.log( +"100px" ); // NaN
/* Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.

В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например "100px" или "12pt" в CSS. Также во множестве стран символ валюты записывается после номинала "19€". Так как нам получить числовое значение из таких строк?

Для этого есть parseInt и parseFloat.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой: */
console.log( parseInt('100px') ); // 100
console.log( parseFloat('12.5em') ); // 12.5
console.log( parseInt('12.3') ); // 12, вернётся только целая часть
console.log( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
/* Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
 */
console.log( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
/* Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
 */
console.log( parseInt('0xff', 16) ); // 255
console.log( parseInt('ff', 16) ); // 255, без 0x тоже работает

console.log( parseInt('2n9c', 36) ); // 123456
/* Другие математические функции
В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:
 */
Math.random()
/* Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
 */
console.log( Math.random() ); // 0.1234567894322
console.log( Math.random() ); // 0.5435252343232
console.log( Math.random() ); // ... (любое количество псевдослучайных чисел)
/* Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.
 */
console.log( Math.max(3, 5, -10, 0, 1) ); // 5
console.log( Math.min(1, 2) ); // 1
Math.pow(n, power)
//Возвращает число n, возведённое в степень power
console.log( Math.pow(2, 10) ); // 2 в степени 10 = 1024
console.log( 1.35.toFixed(1) ); // 1.4
console.log( 6.35.toFixed(1) ); // 6.3
console.log( random(1, 5) ); // 1.2345623452
console.log( random(1, 5) ); // 3.7894332423
console.log( random(1, 5) ); // 4.3435234525
console.log( randomInteger(1, 5) ); // 1
console.log( randomInteger(1, 5) ); // 3
console.log( randomInteger(1, 5) ); // 5
function randomInteger(min, max) {
  // получить случайное число от (min-0.5) до (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

console.log( randomInteger(1, 3) );
/* Другое правильное решение – это использовать Math.floor для получения случайного числа от min до max+1: */
function randomInteger(min, max) {
  // случайное число от min до (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}
console.log( randomInteger(1, 3) );
/* Теперь все интервалы отображаются следующим образом:

число от 1  ... до 1.9999999999  округлится до 1
число от 2  ... до 2.9999999999  округлится до 2
число от 3  ... до 3.9999999999  округлится до 3
Все интервалы имеют одинаковую длину, что выравнивает вероятность получения случайных чисел. */