'use strict';

/* Типы данных
Стандарт ECMAScript определяет 9 типов:

6 типов данных являющихся примитивами:
Undefined (Неопределенный тип)  : typeof instance === "undefined"
Boolean (Булев, Логический тип) : typeof instance === "boolean"
Number (Число) : typeof instance === "number"
String (Строка) : typeof instance === "string"
BigInt  : typeof instance === "bigint"
Symbol (в ECMAScript 6)  : typeof instance === "symbol"
Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
Object (Объект) : typeof instance === "object". Прострая структура, используемая не только для хранения данных данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map, new Set, new WeakMap, new WeakSet, new Date и множество других структур;
и Function : typeof instance === "function". Специальный случай, упрощающий определение типа для Функций, несмотря на то, что все функции конструктивно унаследованы от Objec */

/* Динамическая типизация
JavaScript является слабо типизированным или динамическим языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов:
 */
var foo = 42; // сейчас foo типа Number
foo = "bar"; // а теперь foo типа String
foo = true;  // foo становится типа Boolean


// Динамическая типизация
/* Динами́ческая типиза́ция — приём используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. ... Примеры языков с динамической типизацией — Smalltalk, Python, Objective-C, Ruby, PHP, Perl, JavaScript, Лисп.


Только динамическая вызывала у меня стойкое ощущение, что я пишу детский псевдокод, который сработает, только если сойдутся звезды.

Динамическая типизация — это игрушка, штука, которая подойдет, когда ты решил закодить что-то в одного, и забыть об этом. Когда ты собрался вести разработку, когда с твоим кодом будут работать другие люди, когда код вылезет на прод и начнет решать проблемы пользователей, обновляясь раз в неделю — динамическая типизация абсолютно нахрен неприемлема. Просто запомни это и иди менять расширения своих файлов с .js на .ts.

Основные принципы программирования: статическая и динамическая типизация
Переводы, 13 января 2017 в 13:11
 15 703
Обложка поста
Перевод статьи «Programming Concepts: Static vs. Dynamic Type Checking»

Рассказывает Аарон Краус 

Когда вы изучаете языки программирования, то в разговорах часто слышите фразы наподобие “статически типизированный” или “динамически типизированный”. Эти понятия описывают процесс проверки соответствия типов, и как статическая проверка типов, так и динамическая, относятся к разным системам типов. Система типов — это набор правил, которые присваивают свойство, называющееся “тип”, различным сущностям в программе: переменным, выражениям, функциям или модулями — с конечной целью уменьшения количества ошибок путём подтверждения того, что данные отображаются корректно. 

Не волнуйтесь, я знаю, что это всё звучит запутанно, поэтому мы начнём с основ. Что такое “проверка соответствия типов” и что такое вообще тип?

Тип
Тип, также известный как тип данных, это вид классификации, отмечающий одних из различных видов данных. Я не люблю использовать слово “тип” в этом смысле, поэтому скажем так: тип описывает возможные значения структуры (например, переменной), её семантическое значение и способ хранения в памяти. Если это звучит непонятно, подумайте о целых, строках, числах с плавающей запятой и булевых величинах — это всё типы. Типы можно разбить на категории:

Примитивные типы — они варьируются в зависимости от языка, но самые основные — это целые, числа с плавающей запятой, булевы величины и символы.
Сложные типы — они состоят из несколько примитивных типов, например, массив или запись (но не хэш). Все сложные типы считаются структурами данных.
Абстрактные типы — типы, у которых нет конкретной реализации, такие как хэш, множество, очередь и стек.
Прочие типы — например, указатели (тип, в значении которого хранится ссылка на другое место в памяти).
В различных языках могут различаться примитивные типы и структуры данных, но принцип везде один. Тип просто определяет набор правил и протоколов, которым должен соответствовать элемент данных.

Проверка соответствия типов
Существование типов не имеет смысла без процесса подтверждения того, что эти типы имеют логический смысл и программа может быть корректно исполнена. Тут и приходит на помощь проверка соответствия типов. Это процесс подтверждения и применения ограничений типов, и он может проходить как во время компиляции (т.е. статически), так и во время выполнения (т.е. динамически). Проверка соответствия типов нужна, чтобы убедиться в типобезопасности программы, что сведёт количество ошибок, связанных с типами, к минимуму. Это такие ошибки, которые возникают, когда операция производится с тем типом, с каким она производиться не должна: например, когда целое число принимается за число с плавающей запятой, или когда происходит сложения строки и целого:

x = 1 + "2"
Хотя во многих языках и строки, и числа могут использовать оператор +, это зачастую приводит к ошибкам типа, поскольку это выражение обычно не работает с разными типами данных.

Для случая не типобезопасной программы единого алгоритма действий нет. Какие-то языки выдают ошибку типа, которая останавливает компиляцию или выполнение, а в каких-то есть встроенные обработчики таких ошибок (что позволяет разработчикам порой ошибаться при работе с типами). Вне зависимости от этого, процесс проверки типов — это необходимость.

Теперь, когда мы знаем, что такое типы и как работает проверка соответствия типов, рассмотрим два основных вида проверки: статическую и динамическую.

Статическая проверка типов
Язык обладает статической типизацией, если тип переменной известен во время компиляции, а не выполнения. Типичными примерами таких языков являются Ada, C, C++, C#, JADE, Java, Fortran, Haskell, ML, Pascal, и Scala.

Большим преимуществом статической проверки типов является тот факт, что большую часть ошибок типов можно отловить на ранней стадии разработки. Статическая типизация обычно приводит к более быстрому исполнению скомпилированного кода, потому что компилятор знает точные типы используемых данных и создаёт оптимизированный машинный код. Статическая проверка типов оценивает лишь информацию, доступную во время компиляции, а также может подтвердить, что проверенные условия соблюдаются для всех возможных вариантов исполнения программы, что избавляет от необходимости проверки перед каждым запуском программы. Без статической проверки типов даже 100%-ное покрытие тестами не всегда поможет выявить некоторые ошибки типизации.

Динамическая проверка типов
Динамическая проверка типов — это процесс подтверждения типобезопасности программы во время её выполнения. Типичными примерами динамически типизированных языков являются Groovy, JavaScript, Lisp, Lua, Objective-C, PHP, Prolog, Python, Ruby, Smalltalk и Tcl.

Большая часть типобезопасных языков в той или иной мере использует динамическую проверку типов, даже если основным инструментом является статическая. Так происходит из-за того, что многие свойства невозможно проверить статически. Предположим, что программа определяет два типа, A и B, где B — подтип A. Если программа пытается преобразовать тип A в тип B, т.е. произвести понижающее приведение, то эта операция будет одобрена лишь в том случае, когда значение на самом деле имеет тип B. Поэтому для подтверждения безопасности операции нужна динамическая проверка типов.

В отличие от статической проверки типов, динамическая может привести к прекращению выполнения программы из-за ошибок типизации. В некоторых языках этого может избежать (например, благодаря обработке ошибок или слабой типобезопасности). Для избежания подобных ситуации рекомендуется использовать юнит-тесты.

Код, прошедший динамическую проверку типов, в общем случае менее оптимизирован; кроме того, существует возможность ошибок выполнения и, как следствие, необходимость проверки перед каждым запуском. Тем не менее, динамическая типизация открывает дорогу другим, мощным техникам программирования, например, метапрограммированию.

Типичные заблуждения
Миф 1: статическая / динамическая типизация ==  сильная / слабая типизация
Обычным заблуждение является мнение, что все статически типизированные языки являются сильно типизированными, а динамически типизированные — слабо типизированными. Это неверно, и вот почему.

Сильно типизированный язык — это такой язык, в котором переменные привязаны к конкретным типам данных, и который выдаст ошибку типизации в случае несовпадения ожидаемого и фактического типов — когда бы не проводилась проверка. Проще всего представить сильно типизированный язык как язык с высокой типобезопасностью. Например, в уже использованном выше куске кода сильно типизированный язык выдаст явную ошибку типизации, которая прервёт выполнение программы:

x = 1 + "2"
Мы часто ассоциируем статически типизированные языки, такие как Java и C#, с сильно типизированным (они такими и являются), поскольку тип данных задаётся явно при инициализации переменной — как в этом примере на Java:

String foo = new String("hello world");
Тем не менее, Ruby, Python и JavaScript (все они обладaют динамической типизацией) также являются сильно типизированными, хотя разработчику и не нужно указывать тип переменной при объявлении. Рассмотрим такой же пример, но написанный на Ruby:

foo = "hello world"
Оба языка являются сильно типизированными, но используют разные методы проверки типов. Такие языки, как Ruby, Python и JavaScript не требуют явного определения типов из-за вывода типов — способности программно выводить нужный тип переменной в зависимости от её значения. Вывод типов — это отдельное свойство языка, и не относится к системам типов.

Слабо типизированный язык — это язык, в котором переменные не привязаны к конкретному типу данных; у них всё ещё есть тип, но ограничения типобезопасности гораздо слабее. Рассмотрим следующий пример кода на PHP:

$foo = "x";
$foo = $foo + 2; // not an error
echo $foo;       // 2
Поскольку PHP обладает слабой типизацией, ошибки в этом коде нет. Аналогично предыдущему предположению, не все слабо типизированные языки являются динамически типизированными: PHP — это динамически типизированный язык, но вот C — тоже язык со слабой типизацией — воистину статически типизирован.

Миф разрушен.

Хотя статическая / динамическая  и сильная / слабая системы типов и являются разными, они обе связаны с типобезопасностью. Проще всего это выразить так: первая система говорит о том, когда проверяется типобезопасность, а вторая — как.

Миф 2: статическая / динамическая типизация == компилируемые / интерпретируемые языки
Будет верным сказать, что большинство статически типизированных языков обычно компилируются, а динамически типизированных — интерпретируются, но обобщить это утверждение нельзя, и тому есть простой пример.

Когда мы говорим о типизации языка, мы говорим о языке как о целом. Например, неважно, какую версию Java вы используете — она всегда будет статически типизированной. Это отличается от того случая, когда язык является компилируемым или интерпретируемым, поскольку в этом случае мы говорим о конкретной реализации языка. В теории, любой язык может быть как компилируемым, так и интерпретируемым. Самая популярная реализация языка Java использует компиляцию в байткод, который интерпретирует JVM — но есть и иные реализации этого языка, которые компилируются напрямую в машинный код или интерпретируются как есть.

Если это всё ещё непонятно, советую прочесть одну из предыдущих статей этого цикла.

Заключение
Я знаю, что в этой статье было много информации — но я верю, что вы справились. Я бы хотел вынести информацию про сильную / слабую типизацию в отдельную статью, но это не такая важная тема; к тому же, нужно было показать, что этот вид типизации не имеет отношения к проверке типов.

Нет однозначного ответа на вопрос “какая типизация лучше?” — у каждой есть свои преимущества и недостатки. Некоторые языки — такие как Perl и C# — даже позволяют вам самостоятельно выбирать между статической и динамической системами проверки типов. Понимание этих систем позволит вам лучше понять природу возникающих ошибок, а также упростит борьбу с ними. */
/* 
Примитивные значения
Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».

Булевый тип данных
Булевый тип представляет логическую сущность и имеет два значения: true (истина) и false (ложь). Смотрите Boolean и Boolean для получения подробностей.

Null
Этот тип данных имеет всего одно значение: null. Смотрите null и Null для получения подробностей.

Undefined
Переменная, которой не было присвоено значение, будет иметь значение undefined. Смотрите undefined и undefined для получения подробностей.

Числа
В соответствии со стандартом ECMAScript, существует только один числовой тип, который представляет собой 64-битное число двойной точности согласно стандарту IEEE 754. Другими словами, специального типа для целых чисел в JavaScript нет. Это означает, что при числовых операциях вы можете получить неточное (округлённое) значение. В дополнение к возможности представлять числа с плавающей запятой, есть несколько символических значений: +Infinity (положительная бесконечность), -Infinity (отрицательная бесконечность), и NaN (не число).

Для получения самого большого или самого меньшего доступного значения в пределах +/-Infinity, можно использовать константы Number.MAX_VALUE или Number.MIN_VALUE. А начиная с ECMAScript 2015, вы также можете проверить, находится ли число в безопасном для целых чисел диапазоне, используя метод Number.isSafeInteger(), либо константы Number.MAX_SAFE_INTEGER и Number.MIN_SAFE_INTEGER. За пределами этого диапазона операции с целыми числами будут небезопасными, и возвращать приближённые значения.

Ноль в JavaScript имеет два представления: -0 и +0. («0» это синоним +0). На практике это имеет малозаметный эффект. Например, выражение +0 === -0 является истинным. Однако, это может проявиться при делении на ноль:

> 42 / +0
Infinity
> 42 / -0
-Infinity
Хотя число в большинстве случаев представляет только своё значение, JavaScript предоставляет несколько бинарных операций. Они могут использоваться для того, чтобы представлять число как несколько булевых значений, с помощью битовой маски. Это считается плохой практикой, так как JavaScript предлагает другие способы представления булевых значений (например, массив элементов с булевыми значениями или объект, содержащий набор булевых свойств). Кроме того, битовые маски часто делают код более трудным для чтения, понимания и дальнейшей поддержки. Эта техника может быть необходима в условиях технических ограничений, таких как объём локального хранилища данных, или в такой экстремальной ситуации, когда каждый бит передаваемый по сети на счету. Данный подход следует использовать как крайнюю меру, когда не остаётся других путей для необходимой оптимизации.

Текстовые строки
В JavaScript для представления текстовых данных служит тип String. Он представляет собой цепочку «элементов» 16-битных беззнаковых целочисленных значений. Каждый такой элемент занимает свою позицию в строке. Первый элемент имеет индекс 0, следующий — 1, и так далее. Длина строки — это количество элементов в ней.

В отличие от языков подобных C, строки в JavaScript являются иммутабельными. Это означает, что после того, как строковое значение создано, его нельзя модифицировать. Остаётся лишь создать новую строку путём совершения некой операции над исходной строкой. Например:

Получить часть исходной строки выборкой отдельных символов, либо применением метода String.substr().
Объединить две строки в одну, применив оператор (+) или метод String.concat().
Избегайте повсеместного использования строк в своем коде!
Иногда может показаться соблазнительным использование строк для представления сложных структур данных. Это даст небольшие краткосрочные выгоды:

Легко соединять данные в кучу сложением строк.
Легко отлаживать (данные выглядят «как есть», в читаемом текстовом виде).
Строки — это распространённый формат данных, используемый разнообразными API (поля ввода, значения локального хранилища, XMLHttpRequest возвращает ответ в виде строки, и т. д.) и использовать только строки может показаться заманчивым.
Несмотря на то, что в строке можно выразить данные любой сложности, делать это — не самая лучшая идея. Например, используя разделитель, строку можно использовать как список элементов (массив JavaScript будет более подходящим решением). К сожалению, если такой сепаратор встретится в значении одного из элементов, такой список будет сломан. Выходом может стать добавление символа экранирования, и т. д. Всё это потребует добавления множества ненужных правил, и станет обременительным при поддержке.

Используйте строки только для текстовых данных. Для составных структур преобразуйте строки в подобающие конструкции.

Тип данных Символ (Symbol)
Символы являются нововведением JavaScript начиная с ECMAScript 2015. Символ — это уникальное и иммутабельное примитивное значение, которое может быть использовано как ключ для свойства объекта (смотрите ниже). В некоторых языках программирования символы называются атомами. Их также можно сравнить с именованными значениями перечисления (enum) в языке C. Подробнее смотрите Symbol и Symbol.

Тип данных Большое целое (BigInt)
BigInt является встроенным объектом, который предоставляет способ представления целых чисел, которые больше 2 53, что является наибольшим числом, которое JavaScript может надежно представить с помощью Number примитива.

> let bigInt = 19241924124n;
> console.log(bigInt);
19241924124n
> console.log(typeof bigInt);
"bigint"
Объекты
В компьютерной терминологии, объект — это значение в памяти, на которое возможно сослаться с помощью идентификатора.

Свойства
В JavaScript объект может расцениваться как набор свойств. Литеральная инициализация объекта задаёт определённое количество начальных свойств, и в процессе работы приложения поля могут добавляться и удаляться. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвлённые иерархии данных. Каждое свойство объекта идентифицируется ключом, в качестве которого может выступать значение с типом Строка или Символ.

Есть два типа свойств: свойство-значение и свойство-акцессор (свойство, обёрнутое в геттер и сеттер). Они отличаются определенными атрибутами.

Свойство-значение
Ассоциирует ключ со значением, и имеет следующие атрибуты:

Атрибуты свойства-значения
Атрибут	Тип	Описание	Значение по умолчанию
[[Value]]	Любой тип JavaScript	Значение, возвращаемое при обращении к свойству.	undefined
[[Writable]]	Boolean	Если false, то [[Value]] свойства не может быть изменено.	false
[[Enumerable]]	Boolean	Если true, свойство будет перечислено в цикле for...in. Смотрите подробнее Перечисляемость и владение свойствами.	false
[[Configurable]]	Boolean	Если false, то свойство не может быть удалено, а его атрибуты, кроме [[Value]] и [[Writable]] не могут быть изменены.	false
Устаревшие атрибуты (присутствуют в ECMAScript 3, но переименованы в ECMAScript 5)
Атрибут	Тип	Описание
Read-only	Boolean	Зарезервировано по атрибуту [[Writable]] ES5.
DontEnum	Boolean	Зарезервировано по атрибуту [[Enumerable]] ES5.
DontDelete	Boolean	Зарезервировано по атрибуту [[Configurable]] ES5.
Свойство-акцессор
Ассоциирует ключ с одной из двух функций-акцессоров (геттер и сеттер) для получения или изменения значения свойства, и имеет следующий атрибуты:

Атрибуты свойства-акцессора
Атрибут	Тип	Описание	Значение по умолчанию
[[Get]]	Function или undefined	Функция вызывается без параметров и возвращает значение свойства каждый раз, когда происходит чтение свойства. Смотрите также get.	undefined
[[Set]]	Function или undefined	Функция вызывается с одним аргументом, содержащим присваиваемое значение, каждый раз, когда происходит попытка присвоить свойству новое значение. Смотрите также set.	undefined
[[Enumerable]]	Boolean	Если true, свойство будет перечислено в цикле for...in.	false
[[Configurable]]	Boolean	Если false, то свойство не может быть удалено, и не может быть преобразовано в свойство-значение.	false
Примечание: Атрибуты обычно используются движком JavaScript, поэтому вы не можете обратиться к ним напрямую (смотрите подробнее Object.defineProperty()). Вот почему в таблицах выше они помещены в двойные квадратные скобки вместо одиночных.

«Обычные» объекты и функции
Объект JavaScript — это таблица соотношений между ключами и значениями. Ключи — это строки (или Symbol), а значения могут быть любыми. Это делает объекты полностью отвечающими определению хеш-таблицы.

Функции — это обычные объекты, имеющие дополнительную возможность быть вызванными для исполнения.

Даты
Для работы с датами служит встроенный глобальный объект Date.

Массивы общие и типизированные
Массив — это обычный объект с дополнительной связью между целочисленными ключами его свойств и специальным свойством length. Вдобавок ко всему, массивы наследуют Array.prototype, предоставляющий исчерпывающий набор методов для манипуляции массивами. Например, метод indexOf (служит для поиска значения в массиве), push (добавляет элемент в конец массива) и т. д. Всё это делает массив идеальным кандидатом для представления списков и перечислений.

Типизированный массив является новинкой ECMAScript Edition 6 и является массивоподобным представлением для лежащего в его основе бинарного буфера памяти. Следующая таблица поможет вам найти соответствующие типы языка C:

Объекты TypedArray
Тип	Диапазон значений	Размер (байты)	Описание	Тип Web IDL	Эквивалентный тип языка C
Int8Array	-128 до 127	1	8-битное целое со знаком с дополнением до двух	byte	int8_t
Uint8Array	0 до 255	1	8-битное беззнаковое целое	octet	uint8_t
Uint8ClampedArray	0 до 255	1	8-битное беззнаковое целое (фиксированное от 0 до 255)	octet	uint8_t
Int16Array	-32768 до 32767	2	16-битное целое со знаком с дополнением до двух	short	int16_t
Uint16Array	0 до 65535	2	16-битное беззнаковое целое	unsigned short	uint16_t
Int32Array	-2147483648 до 2147483647	4	32-битное целое со знаком с дополнением до двух	long	int32_t
Uint32Array	0 до 4294967295	4	32-битное беззнаковое целое	unsigned long	uint32_t
Float32Array	1.2x10-38 to 3.4x1038	4	32-битное число с плавающей точкой IEEE-стандарта (7 значащих цифр, нпример 1.123456)	unrestricted float	float
Float64Array	5.0x10-324 to 1.8x10308	8	64-битное число с плавающей точкой IEEE-стандарта (16 значащих цифр, например, 1.123...15)	unrestricted double	doubleКоллекции: Maps, Sets, WeakMaps, WeakSets
Эти наборы данных используют ссылку на объект в качестве ключа, и введены в JavaScript с приходом ECMAScript Edition 6. Set и WeakSet являют собой набор уникальных объектов, в то время как Map и WeakMap ассоциируют с объектом (выступающим в качестве ключа) некоторое значение. Разница между Map и WeakMap заключается в том, что только у Map ключи являются перечисляемыми. Это позволяет оптимизировать сборку мусора для WeakMap.

Можно было бы написать собственную реализацию Map и Set на чистом ECMAScript 5. Однако, так как объекты нельзя сравнивать на больше или меньше, то производительность поиска в самодельной реализации будет вынужденно линейной. Нативная реализация (включая WeakMap) имеет производительность логарифмически близкую к константе.

Обычно, для привязки некоторых данных к узлу DOM, приходится устанавливать свойства этому узлу непосредственно, либо использовать его атрибуты data-*. Обратной стороной такого подхода является то, что эти данные будут доступны любому скрипту, работающему в том же контексте. Maps и WeakMaps дают возможность приватной привязки данных к объекту.

Структурированные данные: JSON
JSON (JavaScript Object Notation) — это легковесный формат обмена данными, происходящий от JavaScript, но используемый во множестве языков программирования. JSON строит универсальные структуры данных. Смотрите JSON и JSON для детального изучения.

Больше объектов и стандартная библиотека
JavaScript имеет стандартную библиотеку встроенных объектов. Пожалуйста, обратитесь к справочнику, чтобы найти описание всех объектов доступных для работы.

Определение типов оператором typeof
Оператор typeof может помочь определить тип вашей переменной. */